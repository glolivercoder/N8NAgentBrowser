// n8n-agent-ui.js - UI component for interacting with the N8N Agent
document.addEventListener('DOMContentLoaded', () => {
  const agentUI = new N8NAgentUI();
  agentUI.init();
});

class N8NAgentUI {
  constructor() {
    this.elements = {};
    this.currentWorkflow = null;
    this.currentDockerCompose = null;
    this.currentTestScript = null;
    this.appState = null;
    this.activeTab = 'assistant';
    this.isInitialized = false;
  }

  async init() {
    this.cacheElements();
    this.setupEventListeners();
    
    // Carregar a aba ativa do localStorage ou usar a padrão
    const savedTab = localStorage.getItem('n8nAgentActiveTab') || 'assistant';
    this.switchTab(savedTab);
    
    await this.loadSettings();
    this.checkAgentStatus();
    this.isInitialized = true;
  }

  /**
   * Armazena referências a todos os elementos da interface
   */
  cacheElements() {
    // Tab navigation elements
    this.elements.tabs = document.querySelectorAll('.tab');
    this.elements.tabContents = document.querySelectorAll('.tab-content');
    
    // Main containers
    this.elements.agentContainer = document.getElementById('n8n-agent-container');
    this.elements.questionInput = document.getElementById('agent-question-input');
    this.elements.submitButton = document.getElementById('agent-submit-button');
    this.elements.responseContainer = document.getElementById('agent-response-container');
    this.elements.loadingIndicator = document.getElementById('agent-loading-indicator');
    
    // Workflow creation elements
    this.elements.workflowDescriptionInput = document.getElementById('workflow-description-input');
    this.elements.createWorkflowButton = document.getElementById('create-workflow-button');
    this.elements.deployWorkflowButton = document.getElementById('deploy-workflow-button');
    this.elements.workflowJsonOutput = document.getElementById('workflow-json-output');
    this.elements.workflowErrorContainer = document.getElementById('workflow-error-container');
    this.elements.workflowSuccessContainer = document.getElementById('workflow-success-container');
    
    // Docker elements
    this.elements.dockerPortInput = document.getElementById('docker-port-input');
    this.elements.dockerDataPathInput = document.getElementById('docker-data-path-input');
    this.elements.generateDockerComposeButton = document.getElementById('generate-docker-compose-button');
    this.elements.checkContainerStatusButton = document.getElementById('check-container-status-button');
    this.elements.startContainerButton = document.getElementById('start-container-button');
    this.elements.stopContainerButton = document.getElementById('stop-container-button');
    this.elements.dockerStatusDisplay = document.getElementById('docker-status-display');
    this.elements.dockerComposeOutput = document.getElementById('docker-compose-output');
    this.elements.copyDockerComposeButton = document.getElementById('copy-docker-compose-button');
    this.elements.saveDockerComposeButton = document.getElementById('save-docker-compose-button');
    this.elements.dockerErrorContainer = document.getElementById('docker-error-container');
    this.elements.dockerSuccessContainer = document.getElementById('docker-success-container');
    
    // MCP integration elements
    this.elements.mcpTestDescriptionInput = document.getElementById('mcp-test-description-input');
    this.elements.generateMcpTestButton = document.getElementById('generate-mcp-test-button');
    this.elements.mcpTestScriptOutput = document.getElementById('mcp-test-script-output');
    this.elements.playwrightRepoPathInput = document.getElementById('playwright-repo-path-input');
    this.elements.clonePlaywrightRepoButton = document.getElementById('clone-playwright-repo-button');
    this.elements.runMcpTestButton = document.getElementById('run-mcp-test-button');
    this.elements.mcpCommandInput = document.getElementById('mcp-command-input');
    this.elements.executeCommandButton = document.getElementById('execute-command-button');
    this.elements.mcpCommandOutput = document.getElementById('mcp-command-output');
    this.elements.mcpErrorContainer = document.getElementById('mcp-error-container');
    this.elements.mcpSuccessContainer = document.getElementById('mcp-success-container');
    
    // Settings elements
    this.elements.n8nUrlInput = document.getElementById('n8n-url-input');
    this.elements.n8nApiKeyInput = document.getElementById('n8n-api-key-input');
    this.elements.openrouterApiKeyInput = document.getElementById('openrouter-api-key-input');
    this.elements.mcpPlaywrightUrlInput = document.getElementById('mcp-playwright-url-input');
    this.elements.saveSettingsButton = document.getElementById('save-settings-button');
    this.elements.connectionStatus = document.getElementById('connection-status');
    this.elements.settingsErrorContainer = document.getElementById('settings-error-container');
    this.elements.settingsSuccessContainer = document.getElementById('settings-success-container');
    
    // Containers de erro e sucesso para cada aba
    this.elements.errorContainers = {
      docker: this.elements.dockerErrorContainer,
      mcp: this.elements.mcpErrorContainer,
      workflow: this.elements.workflowErrorContainer,
      settings: this.elements.settingsErrorContainer,
      assistant: document.getElementById('assistant-error-container')
    };
    
    this.elements.successContainers = {
      docker: this.elements.dockerSuccessContainer,
      mcp: this.elements.mcpSuccessContainer,
      workflow: this.elements.workflowSuccessContainer,
      settings: this.elements.settingsSuccessContainer,
      assistant: document.getElementById('assistant-success-container')
    };
  }

  setupEventListeners() {
    // Tab navigation
    this.elements.tabs?.forEach(tab => {
      tab.addEventListener('click', () => {
        const tabId = tab.getAttribute('data-tab');
        this.switchTab(tabId);
      });
    });
    
    // Question answering
    this.elements.submitButton?.addEventListener('click', () => this.handleQuestionSubmit());
    this.elements.questionInput?.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') this.handleQuestionSubmit();
    });
    
    // Workflow creation
    this.elements.createWorkflowButton?.addEventListener('click', () => this.handleWorkflowCreation());
    this.elements.deployWorkflowButton?.addEventListener('click', () => this.handleDeployWorkflow());
    
    // Docker integration
    this.elements.generateDockerComposeButton?.addEventListener('click', () => this.handleGenerateDockerCompose());
    this.elements.startContainerButton?.addEventListener('click', () => this.handleStartContainer());
    this.elements.stopContainerButton?.addEventListener('click', () => this.handleStopContainer());
    this.elements.copyDockerComposeButton?.addEventListener('click', () => {
      this.copyToClipboard(this.elements.dockerComposeOutput.value);
      this.displaySuccess('docker', 'Docker Compose copiado para a área de transferência');
    });
    this.elements.saveDockerComposeButton?.addEventListener('click', () => this.handleSaveDockerCompose());
    
    // MCP integration
    this.elements.clonePlaywrightRepoButton?.addEventListener('click', () => this.handleClonePlaywrightRepo());
    this.elements.generateMcpTestButton?.addEventListener('click', () => this.handleGenerateMcpTest());
    this.elements.runMcpTestButton?.addEventListener('click', () => this.handleRunMcpTest());
    this.elements.copyMcpTestButton?.addEventListener('click', () => {
      this.copyToClipboard(this.elements.mcpTestScriptOutput.value);
      this.displaySuccess('mcp', 'Script de teste copiado para a área de transferência');
    });
    this.elements.executeCommandButton?.addEventListener('click', () => this.handleExecuteCommand());
    
    // Settings
    this.elements.saveSettingsButton?.addEventListener('click', () => this.saveSettings());
    
    // Listen for state updates from background script
    chrome.runtime.onMessage.addListener((message) => {
      if (message.action === 'stateUpdated') {
        this.updateUIFromState(message.state);
      }
    });
  }

  /**
 * Verifica o status do agente e atualiza o estado global da aplicação
 * @returns {Promise<void>}
 */
async checkAgentStatus() {
  try {
    // Verificar conexão com o agente
    const response = await this.sendAgentRequest('ping');
    const isConnected = response && response.success;
    this.updateConnectionStatus(isConnected);
    
    if (isConnected) {
      // Se conectado, obter o estado global da aplicação
      const stateResponse = await this.sendAgentRequest('getAppState');
      if (stateResponse && stateResponse.state) {
        this.updateUIFromState(stateResponse.state);
      }
      
      // Verificar status do Docker se conectado (sem exibir mensagens)
      await this.handleCheckContainerStatus(false);
    }
  } catch (error) {
    console.error('Erro ao verificar status do agente:', error);
    this.updateConnectionStatus(false);
  }
}

  /**
   * Atualiza o status de conexão na interface
   * @param {boolean} isConnected - Se o agente está conectado
   */
  updateConnectionStatus(isConnected) {
    if (this.elements.connectionStatus) {
      this.elements.connectionStatus.textContent = isConnected ? 'Conectado' : 'Desconectado';
      
      if (isConnected) {
        this.elements.connectionStatus.classList.remove('disconnected');
        this.elements.connectionStatus.classList.add('connected');
      } else {
        this.elements.connectionStatus.classList.remove('connected');
        this.elements.connectionStatus.classList.add('disconnected');
      }
    }
    
    // Habilitar/desabilitar botões de ação com base no status de conexão
    const actionButtons = [
      this.elements.submitButton,
      this.elements.createWorkflowButton,
      this.elements.deployWorkflowButton,
      this.elements.generateDockerComposeButton,
      this.elements.startContainerButton,
      this.elements.stopContainerButton,
      this.elements.clonePlaywrightRepoButton,
      this.elements.generateMcpTestButton,
      this.elements.runMcpTestButton,
      this.elements.executeCommandButton
    ];
    
    actionButtons.forEach(button => {
      if (button) {
        button.disabled = !isConnected;
      }
    });
    
    // O botão de salvar configurações sempre permanece habilitado
    if (this.elements.saveSettingsButton) {
      this.elements.saveSettingsButton.disabled = false;
    }
  }

  async handleQuestionSubmit() {
    const question = this.elements.questionInput?.value.trim();
    if (!question) return;
    
    this.setLoading(true);
    this.clearResponse();
    
    try {
      const response = await this.sendAgentRequest('answerQuestion', {
        question,
        context: []
      });
      
      this.displayResponse(response);
    } catch (error) {
      this.displayError('Failed to get answer: ' + error.message);
    } finally {
      this.setLoading(false);
    }
  }

  async handleWorkflowCreation() {
    // Validar descrição do workflow
    const description = this.elements.workflowDescriptionInput?.value.trim();
    if (!description) {
      this.displayError('workflow', 'Por favor, informe uma descrição para o workflow');
      return;
    }
    
    try {
      this.setLoading(true);
      
      // Verificar se a chave API do OpenRouter está configurada
      const stateResponse = await this.sendAgentRequest('getAppState');
      if (!stateResponse?.state?.settings?.openrouterApiKey) {
        this.displayError('workflow', 'Chave API do OpenRouter não configurada. Configure-a na aba de Configurações.');
        return;
      }
      
      // Solicitar criação do workflow
      const response = await this.sendAgentRequest('createWorkflow', {
        description,
        requirements: {
          // Adicionar requisitos específicos do workflow, se necessário
          includeAuthentication: description.toLowerCase().includes('autenticação'),
          includeErrorHandling: true
        }
      });
      
      if (response && response.success && response.workflow) {
        // Armazenar e exibir o workflow gerado
        this.currentWorkflow = response.workflow;
        if (this.elements.workflowJsonOutput) {
          this.elements.workflowJsonOutput.value = JSON.stringify(response.workflow, null, 2);
        }
        
        // Habilitar botão de deploy se o workflow foi gerado com sucesso
        if (this.elements.deployWorkflowButton) {
          this.elements.deployWorkflowButton.disabled = false;
        }
        
        this.displaySuccess('workflow', 'Workflow gerado com sucesso!');
      } else {
        this.displayError('workflow', 'Falha ao gerar workflow: ' + (response?.error || 'Erro desconhecido'));
      }
    } catch (error) {
      console.error('Erro ao gerar workflow:', error);
      this.displayError('workflow', 'Erro ao gerar workflow: ' + error.message);
    } finally {
      this.setLoading(false);
    }
  }

  async handleDeployWorkflow() {
    if (!this.currentWorkflow) {
      this.displayError('workflow', 'Nenhum workflow disponível para implantar. Gere um workflow primeiro.');
      return;
    }
    
    try {
      this.setLoading(true);
      const response = await this.sendAgentRequest('deployWorkflow', {
        workflow: this.currentWorkflow,
        activate: true
      });
      
      if (response.success) {
        this.displaySuccess('workflow', 'Workflow implantado com sucesso! ID: ' + response.workflowId);
      } else {
        this.displayError('workflow', 'Falha ao implantar workflow: ' + (response.error || 'Erro desconhecido'));
      }
    } catch (error) {
      this.displayError('workflow', 'Erro ao implantar workflow: ' + error.message);
    } finally {
      this.setLoading(false);
    }
  }

  async handleGenerateMcpTest() {
    const description = this.elements.mcpTestDescriptionInput?.value.trim();
    if (!description) {
      this.displayError('mcp', 'Por favor, informe uma descrição para o teste');
      return;
    }
    
    try {
      this.setLoading(true);
      const response = await this.sendAgentRequest('generateMcpTest', {
        description,
        requirements: {}
      });
      
      if (response.success && response.testScript) {
        this.currentTestScript = response.testScript;
        this.elements.mcpTestScriptOutput.value = response.testScript;
        this.displaySuccess('mcp', 'Script de teste gerado com sucesso!');
      } else {
        this.displayError('mcp', 'Falha ao gerar script de teste: ' + (response.error || 'Erro desconhecido'));
      }
    } catch (error) {
      this.displayError('mcp', 'Erro ao gerar script de teste: ' + error.message);
    } finally {
      this.setLoading(false);
    }
  }

  async handleRunMcpTest() {
    if (!this.currentTestScript) {
      this.displayError('mcp', 'Nenhum script de teste disponível para executar. Gere um script de teste primeiro.');
      return;
    }
    
    try {
      this.setLoading(true);
      const response = await this.sendAgentRequest('runMcpTest', {
        testScript: this.currentTestScript
      });
      
      if (response.success) {
        this.displaySuccess('mcp', 'Script de teste executado com sucesso!');
      } else {
        this.displayError('mcp', 'Falha ao executar script de teste: ' + (response.error || 'Erro desconhecido'));
      }
    } catch (error) {
      this.displayError('mcp', 'Erro ao executar script de teste: ' + error.message);
    } finally {
      this.setLoading(false);
    }
  }

  setupTabNavigation() {
    // Remove inline script from HTML and implement it here
    this.elements.tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Update active tab
        this.elements.tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Show corresponding content
        const tabId = tab.getAttribute('data-tab');
        this.activeTab = tabId;
        
        this.elements.tabContents.forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(`${tabId}-tab`).classList.add('active');
        
        // Save active tab to local storage
        localStorage.setItem('n8nAgentActiveTab', tabId);
        
        // Perform tab-specific actions
        this.handleTabChange(tabId);
      });
    });
    
    // Restore last active tab from local storage
    const savedTab = localStorage.getItem('n8nAgentActiveTab');
    if (savedTab) {
      const tabElement = document.querySelector(`.tab[data-tab="${savedTab}"]`);
      if (tabElement) {
        tabElement.click();
      }
    }
  }
  
  switchTab(tabId) {
    if (!tabId) return;
    
    // Atualizar classes das abas
    this.elements.tabs.forEach(tab => {
      if (tab.getAttribute('data-tab') === tabId) {
        tab.classList.add('active');
      } else {
        tab.classList.remove('active');
      }
    });
    
    // Atualizar conteúdo visível
    this.elements.tabContents.forEach(content => {
      if (content.id === `${tabId}-tab`) {
        content.classList.add('active');
      } else {
        content.classList.remove('active');
      }
    });
    
    // Salvar a aba ativa no localStorage
    localStorage.setItem('n8nAgentActiveTab', tabId);
    
    // Armazenar a aba ativa na instância
    this.activeTab = tabId;
    
    // Executar ações específicas para cada aba
    this.handleTabChange(tabId);
  }
  
  handleTabChange(tabId) {
    // Executar ações específicas para cada aba quando ela se torna ativa
    switch(tabId) {
      case 'docker':
        this.handleCheckContainerStatus();
        break;
      case 'settings':
        // Atualizar status de conexão quando a aba de configurações é aberta
        this.checkAgentStatus();
        break;
    }
  }
  
  async loadSettings() {
    try {
      // Get app state from background script
      const response = await this.sendBackgroundRequest('getAppState');
      if (response.success && response.state) {
        this.appState = response.state;
        this.updateUIFromSettings(this.appState.settings);
      }
    } catch (error) {
      console.error('Failed to load settings:', error);
      this.displayError('settings', 'Failed to load settings: ' + error.message);
    }
  }
  
  updateUIFromSettings(settings) {
    if (!settings) return;
    
    // Update settings form
    if (this.elements.n8nUrlInput) {
      this.elements.n8nUrlInput.value = settings.n8nApiUrl || '';
    }
    
    if (this.elements.n8nApiKeyInput) {
      this.elements.n8nApiKeyInput.value = settings.n8nApiKey || '';
    }
    
    if (this.elements.openrouterApiKeyInput) {
      this.elements.openrouterApiKeyInput.value = settings.openrouterApiKey || '';
    }
    
    if (this.elements.mcpPlaywrightUrlInput) {
      this.elements.mcpPlaywrightUrlInput.value = settings.mcpConfig?.playwrightRepoUrl || '';
    }
    
    // Update Docker form
    if (this.elements.dockerPortInput && settings.dockerConfig) {
      this.elements.dockerPortInput.value = settings.dockerConfig.port || '5678';
    }
    
    if (this.elements.dockerDataPathInput && settings.dockerConfig) {
      this.elements.dockerDataPathInput.value = settings.dockerConfig.dataPath || './n8n-data';
    }
    
    // Update MCP form
    if (this.elements.playwrightRepoPathInput && settings.mcpConfig) {
      this.elements.playwrightRepoPathInput.value = settings.mcpConfig.playwrightRepoPath || './mcp-playwright';
    }
  }
  
  /**
   * Atualiza a interface com base no estado global da aplicação
   * @param {Object} state - Estado global da aplicação
   */
  updateUIFromState(state) {
    if (!state) return;
    
    // Atualizar configurações
    if (state.settings) {
      this.updateUIFromSettings(state.settings);
    }
    
    // Atualizar status de conexão
    if (state.isConnected !== undefined) {
      this.updateConnectionStatus(state.isConnected);
    }
    
    // Atualizar status do Docker
    if (state.dockerStatus) {
      const statusText = state.dockerStatus.running ? 'Rodando' : 'Parado';
      if (this.elements.dockerStatusDisplay) {
        this.elements.dockerStatusDisplay.textContent = statusText;
        this.elements.dockerStatusDisplay.className = state.dockerStatus.running ? 'status-running' : 'status-stopped';
      }
      
      // Atualizar botões de ação do Docker com base no status
      if (this.elements.startContainerButton && this.elements.stopContainerButton) {
        this.elements.startContainerButton.disabled = state.dockerStatus.running;
        this.elements.stopContainerButton.disabled = !state.dockerStatus.running;
      }
    }
    
    // Atualizar workflow
    if (state.lastGeneratedWorkflow) {
      this.currentWorkflow = state.lastGeneratedWorkflow;
      if (this.elements.workflowJsonOutput) {
        this.elements.workflowJsonOutput.value = JSON.stringify(state.lastGeneratedWorkflow, null, 2);
      }
      
      // Habilitar botão de deploy se o workflow foi gerado
      if (this.elements.deployWorkflowButton) {
        this.elements.deployWorkflowButton.disabled = false;
      }
    } else {
      // Desabilitar botão de deploy se não há workflow
      if (this.elements.deployWorkflowButton) {
        this.elements.deployWorkflowButton.disabled = true;
      }
    }
    
    // Atualizar Docker compose
    if (state.lastGeneratedDockerCompose) {
      this.currentDockerCompose = state.lastGeneratedDockerCompose;
      if (this.elements.dockerComposeOutput) {
        this.elements.dockerComposeOutput.value = state.lastGeneratedDockerCompose;
      }
    }
    
    // Atualizar script de teste MCP
    if (state.lastGeneratedTestScript) {
      this.currentTestScript = state.lastGeneratedTestScript;
      if (this.elements.mcpTestScriptOutput) {
        this.elements.mcpTestScriptOutput.value = state.lastGeneratedTestScript;
      }
      
      // Habilitar botão de execução de teste se o script foi gerado
      if (this.elements.runMcpTestButton) {
        this.elements.runMcpTestButton.disabled = false;
      }
    } else {
      // Desabilitar botão de execução de teste se não há script
      if (this.elements.runMcpTestButton) {
        this.elements.runMcpTestButton.disabled = true;
      }
    }
    
    // Verificar se há repositório Playwright clonado
    if (state.playwrightRepoStatus && state.playwrightRepoStatus.cloned) {
      if (this.elements.clonePlaywrightRepoButton) {
        this.elements.clonePlaywrightRepoButton.textContent = 'Repositório Clonado';
        this.elements.clonePlaywrightRepoButton.disabled = true;
      }
      
      // Habilitar botão de geração de teste se o repo está clonado
      if (this.elements.generateMcpTestButton) {
        this.elements.generateMcpTestButton.disabled = false;
      }
    } else {
      if (this.elements.clonePlaywrightRepoButton) {
        this.elements.clonePlaywrightRepoButton.textContent = 'Clonar Repositório';
        this.elements.clonePlaywrightRepoButton.disabled = !state.isConnected;
      }
      
      // Desabilitar botão de geração de teste se o repo não está clonado
      if (this.elements.generateMcpTestButton) {
        this.elements.generateMcpTestButton.disabled = true;
      }
    }
  }
  
  /**
   * Salva as configurações da extensão
   * @returns {Promise<void>}
   */
  async saveSettings() {
    const n8nUrl = this.elements.n8nUrlInput?.value.trim();
    const n8nApiKey = this.elements.n8nApiKeyInput?.value.trim();
    const openrouterApiKey = this.elements.openrouterApiKeyInput?.value.trim();
    const mcpPlaywrightUrl = this.elements.mcpPlaywrightUrlInput?.value.trim();
    
    if (!n8nUrl) {
      this.displayError('settings', 'Por favor, informe a URL da instância N8N');
      return;
    }
    
    if (!openrouterApiKey) {
      this.displayError('settings', 'Por favor, informe a chave API do OpenRouter');
      return;
    }
    
    try {
      this.setLoading(true);
      await this.sendAgentRequest('setApiConfig', {
        apiUrl: n8nUrl,
        apiKey: n8nApiKey,
        openrouterApiKey: openrouterApiKey,
        mcpPlaywrightUrl: mcpPlaywrightUrl
      });
      
      this.displaySuccess('settings', 'Configurações salvas com sucesso');
      await this.loadSettings(); // Reload settings to ensure UI is in sync
      this.checkAgentStatus();
    } catch (error) {
      this.displayError('settings', 'Falha ao salvar configurações: ' + error.message);
    } finally {
      this.setLoading(false);
    }
  }

  // UI Helpers
  /**
   * Controla o estado de carregamento da interface
   * @param {boolean} isLoading - Se a interface está em estado de carregamento
   */
  setLoading(isLoading) {
    if (this.elements.loadingIndicator) {
      this.elements.loadingIndicator.style.display = isLoading ? 'flex' : 'none';
    }
    
    // Desabilitar/habilitar botões de ação durante o carregamento
    const actionButtons = [
      this.elements.submitButton,
      this.elements.createWorkflowButton,
      this.elements.deployWorkflowButton,
      this.elements.generateDockerComposeButton,
      this.elements.startContainerButton,
      this.elements.stopContainerButton,
      this.elements.clonePlaywrightRepoButton,
      this.elements.generateMcpTestButton,
      this.elements.runMcpTestButton,
      this.elements.executeCommandButton
    ];
    
    actionButtons.forEach(button => {
      if (button) {
        button.disabled = isLoading;
      }
    });
    
    // O botão de salvar configurações sempre permanece habilitado
    if (this.elements.saveSettingsButton) {
      this.elements.saveSettingsButton.disabled = false;
    }
  }

  clearResponse() {
    if (this.elements.responseContainer) {
      this.elements.responseContainer.innerHTML = '';
    }
  }

  clearWorkflowResult() {
    if (this.elements.workflowResult) {
      this.elements.workflowResult.innerHTML = '';
    }
  }

  displayResponse(response) {
    if (!this.elements.responseContainer) return;
    
    const responseDiv = document.createElement('div');
    responseDiv.className = 'agent-response';
    
    // Display the answer
    const answerDiv = document.createElement('div');
    answerDiv.className = 'answer';
    answerDiv.textContent = response.answer;
    responseDiv.appendChild(answerDiv);
    
    // Display sources if available
    if (response.sources && response.sources.length > 0) {
      const sourcesDiv = document.createElement('div');
      sourcesDiv.className = 'sources';
      
      const sourcesTitle = document.createElement('h4');
      sourcesTitle.textContent = 'Sources:';
      sourcesDiv.appendChild(sourcesTitle);
      
      const sourcesList = document.createElement('ul');
      response.sources.forEach(source => {
        const sourceItem = document.createElement('li');
        sourceItem.textContent = `${source.title} (Relevance: ${Math.round(source.score * 100)}%)`;
        sourcesList.appendChild(sourceItem);
      });
      
      sourcesDiv.appendChild(sourcesList);
      responseDiv.appendChild(sourcesDiv);
    }
    
    this.elements.responseContainer.appendChild(responseDiv);
  }

  displayError(container, message) {
    // If container is a string, look for the corresponding error container
    const errorContainer = typeof container === 'string' 
      ? this.elements.errorContainers[container] 
      : container;
      
    if (!errorContainer) {
      // Fallback to response container if specific error container not found
      if (container === 'assistant' && this.elements.responseContainer) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = message;
        this.elements.responseContainer.appendChild(errorDiv);
        return;
      }
      console.error('Error container not found:', container);
      alert(message); // Fallback to alert if no container available
      return;
    }
    
    errorContainer.className = 'error-message';
    errorContainer.textContent = message;
    errorContainer.style.display = 'block';
    
    // Auto-hide error after 5 seconds
    setTimeout(() => {
      errorContainer.style.display = 'none';
    }, 5000);
  }
  
  displaySuccess(container, message) {
    // If container is a string, look for the corresponding error container (we'll reuse it for success)
    const successContainer = typeof container === 'string' 
      ? this.elements.errorContainers[container] 
      : container;
      
    if (!successContainer) {
      console.error('Success container not found:', container);
      alert(message); // Fallback to alert if no container available
      return;
    }
    
    successContainer.className = 'success-message';
    successContainer.textContent = message;
    successContainer.style.display = 'block';
    
    // Auto-hide success message after 3 seconds
    setTimeout(() => {
      successContainer.style.display = 'none';
    }, 3000);
  }

  displayWorkflow(workflow) {
    if (!this.elements.workflowResult) return;
    
    const workflowDiv = document.createElement('div');
    workflowDiv.className = 'workflow-preview';
    
    // Display workflow name
    const nameDiv = document.createElement('h3');
    nameDiv.textContent = workflow.name || 'Unnamed Workflow';
    workflowDiv.appendChild(nameDiv);
    
    // Display node count
    const nodeCountDiv = document.createElement('div');
    nodeCountDiv.textContent = `Nodes: ${workflow.nodes?.length || 0}`;
    workflowDiv.appendChild(nodeCountDiv);
    
    // Add deploy button
    const deployButton = document.createElement('button');
    deployButton.textContent = 'Deploy to N8N';
    deployButton.className = 'deploy-button';
    deployButton.addEventListener('click', () => this.deployCurrentWorkflow());
    workflowDiv.appendChild(deployButton);
    
    // Add JSON preview
    const jsonPreview = document.createElement('pre');
    jsonPreview.className = 'json-preview';
    jsonPreview.textContent = JSON.stringify(workflow, null, 2);
    workflowDiv.appendChild(jsonPreview);
    
    this.elements.workflowResult.appendChild(workflowDiv);
  }

  displayWorkflowError(message) {
    if (!this.elements.workflowResult) return;
    
    const errorDiv = document.createElement('div');
    errorDiv.className = 'error-message';
    errorDiv.textContent = message;
    
    this.elements.workflowResult.appendChild(errorDiv);
  }

  displayDeploymentResult(result) {
    if (!this.elements.workflowResult) return;
    
    const deploymentDiv = document.createElement('div');
    deploymentDiv.className = 'deployment-result';
    
    const titleDiv = document.createElement('h4');
    titleDiv.textContent = 'Deployment Result:';
    deploymentDiv.appendChild(titleDiv);
    
    const resultDiv = document.createElement('div');
    resultDiv.textContent = `Workflow deployed with ID: ${result.id}`;
    deploymentDiv.appendChild(resultDiv);
    
    const urlDiv = document.createElement('div');
    urlDiv.innerHTML = `<a href="${this.elements.n8nUrlInput?.value}/workflow/${result.id}" target="_blank">Open in N8N</a>`;
    deploymentDiv.appendChild(urlDiv);
    
    this.elements.workflowResult.appendChild(deploymentDiv);
  }

  /**
   * Envia uma requisição para o background script
   * @param {string} action - Ação a ser executada
   * @param {Object} params - Parâmetros da ação
   * @returns {Promise<Object>} - Resposta do background script
   */
  async sendAgentRequest(action, params = {}) {
    return new Promise((resolve, reject) => {
      chrome.runtime.sendMessage(
        {
          target: 'n8nAgent',
          action,
          params
        },
        response => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
          } else if (response && response.error) {
            reject(new Error(response.error));
          } else {
            resolve(response || {});
          }
        }
      );
    });
  }
  
  /**
   * Alias para sendAgentRequest para compatibilidade com código existente
   * @param {string} action - Ação a ser executada
   * @param {Object} params - Parâmetros da ação
   * @returns {Promise<Object>} - Resposta do background script
   */
  async sendBackgroundRequest(action, params = {}) {
    return this.sendAgentRequest(action, params);
  }
  
  // Docker Integration Methods
  async handleGenerateDockerCompose() {
    const port = this.elements.dockerPortInput?.value.trim() || '5678';
    const dataPath = this.elements.dockerDataPathInput?.value.trim() || './n8n-data';
    
    try {
      this.setLoading(true);
      const response = await this.sendAgentRequest('generateDockerCompose', {
        port,
        dataPath
      });
      
      if (response.success && response.dockerComposeContent) {
        this.elements.dockerComposeOutput.value = response.dockerComposeContent;
        this.currentDockerCompose = response.dockerComposeContent;
        this.displaySuccess('docker', 'Docker Compose gerado com sucesso!');
      } else {
        this.displayError('docker', 'Falha ao gerar Docker Compose: ' + (response.error || 'Erro desconhecido'));
      }
    } catch (error) {
      this.displayError('docker', 'Erro ao gerar Docker Compose: ' + error.message);
    } finally {
      this.setLoading(false);
    }
  }
  
  /**
 * Verifica o status do container Docker e atualiza a interface
 * @param {boolean} showMessages - Se deve exibir mensagens de sucesso/erro
 * @returns {Promise<Object|null>} Status do container ou null em caso de erro
 */
async handleCheckContainerStatus(showMessages = true) {
  try {
    this.setLoading(true);
    const response = await this.sendAgentRequest('checkContainerStatus');
    
    if (response && response.success && response.status) {
      // Atualizar indicador visual de status
      if (this.elements.dockerStatusDisplay) {
        const statusText = response.status.running ? 'Rodando' : 'Parado';
        this.elements.dockerStatusDisplay.textContent = statusText;
        this.elements.dockerStatusDisplay.className = response.status.running ? 'status-running' : 'status-stopped';
      }
      
      // Atualizar botões de ação com base no status
      if (this.elements.startContainerButton && this.elements.stopContainerButton) {
        this.elements.startContainerButton.disabled = response.status.running;
        this.elements.stopContainerButton.disabled = !response.status.running;
      }
      
      // Exibir mensagem de sucesso apenas se solicitado
      if (showMessages) {
        this.displaySuccess('docker', 'Status do container atualizado');
      }
      
      return response.status;
    } else {
      if (showMessages) {
        this.displayError('docker', 'Falha ao verificar status do container: ' + (response?.error || 'Erro desconhecido'));
      }
      return null;
    }
  } catch (error) {
    console.error('Erro ao verificar status do container:', error);
    if (showMessages) {
      this.displayError('docker', 'Erro ao verificar status do container: ' + error.message);
    }
    return null;
  } finally {
    this.setLoading(false);
  }
}

  async handleStartContainer() {
    const port = this.elements.dockerPortInput?.value.trim() || '5678';
    
    try {
      this.setLoading(true);
      const response = await this.sendAgentRequest('startContainer', { port });
      
      if (response.success) {
        this.displaySuccess('docker', 'Container iniciado com sucesso!');
        this.handleCheckContainerStatus();
      } else {
        this.displayError('docker', 'Falha ao iniciar container: ' + (response.error || 'Erro desconhecido'));
      }
    } catch (error) {
      this.displayError('docker', 'Erro ao iniciar container: ' + error.message);
    } finally {
      this.setLoading(false);
    }
  }
  
  async handleStopContainer() {
    try {
      this.setLoading(true);
      const response = await this.sendAgentRequest('stopContainer');
      
      if (response.success) {
        this.displaySuccess('docker', 'Container parado com sucesso!');
        this.handleCheckContainerStatus();
      } else {
        this.displayError('docker', 'Falha ao parar container: ' + (response.error || 'Erro desconhecido'));
      }
    } catch (error) {
      this.displayError('docker', 'Erro ao parar container: ' + error.message);
    } finally {
      this.setLoading(false);
    }
  }
  
  async handleSaveDockerCompose() {
    if (!this.currentDockerCompose) {
      this.displayError('docker', 'Nenhum conteúdo Docker Compose para salvar. Gere um Docker Compose primeiro.');
      return;
    }
    
    try {
      const blob = new Blob([this.currentDockerCompose], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'docker-compose.yml';
      a.click();
      
      URL.revokeObjectURL(url);
      this.displaySuccess('docker', 'Docker Compose salvo como arquivo docker-compose.yml');
    } catch (error) {
      this.displayError('docker', 'Erro ao salvar arquivo Docker Compose: ' + error.message);
    }
  }
  
  displayDockerError(message) {
    this.displayError('docker', message);
  }
  
  // MCP Integration Methods
  async handleClonePlaywrightRepo() {
    const repoPath = this.elements.playwrightRepoPathInput?.value.trim() || './mcp-playwright';
    
    try {
      this.setLoading(true);
      const response = await this.sendAgentRequest('clonePlaywrightRepo', {
        repoPath
      });
      
      if (response.success) {
        this.displaySuccess('mcp', 'Repositório Playwright clonado com sucesso!');
      } else {
        this.displayError('mcp', 'Falha ao clonar repositório Playwright: ' + (response.error || 'Erro desconhecido'));
      }
    } catch (error) {
      this.displayError('mcp', 'Erro ao clonar repositório Playwright: ' + error.message);
    } finally {
      this.setLoading(false);
    }
  }
  
  async handleGenerateTestScript() {
    const workflowJson = this.elements.testWorkflowInput?.value.trim();
    if (!workflowJson) {
      this.displayError('mcp', 'Por favor, informe um fluxo de trabalho JSON');
      return;
    }
    
    let workflow;
    try {
      workflow = JSON.parse(workflowJson);
    } catch (error) {
      this.displayError('mcp', 'JSON inválido: ' + error.message);
      return;
    }
    
    try {
      const response = await this.sendAgentRequest('generateTestScript', {
        workflow: workflow,
        n8nUrl: this.elements.n8nUrlInput?.value.trim() || 'http://localhost:5678'
      });
      
      if (response.testScript) {
        this.currentTestScript = response.testScript;
        this.elements.testScriptContent.textContent = response.testScript;
        this.displaySuccess('mcp', 'Script de teste gerado com sucesso!');
      } else {
        this.elements.testScriptContent.textContent = 'Falha ao gerar script de teste';
        this.displayError('mcp', 'Falha ao gerar script de teste');
      }
    } catch (error) {
      this.elements.testScriptContent.textContent = 'Erro: ' + error.message;
      this.displayError('mcp', 'Erro ao gerar script de teste: ' + error.message);
    }
  }
  
  async handleRunTestScript() {
    if (!this.currentTestScript) {
      this.displayError('mcp', 'Por favor, gere um script de teste primeiro');
      return;
    }
    
    try {
      const response = await this.sendAgentRequest('runPlaywrightTest', {
        script: this.currentTestScript
      });
      
      if (response.success) {
        this.displaySuccess('mcp', 'Teste executado com sucesso!');
        if (response.result) {
          this.elements.commandResult.textContent = JSON.stringify(response.result, null, 2);
        }
      } else {
        this.displayError('mcp', 'Falha ao executar teste: ' + (response.error || 'Erro desconhecido'));
      }
    } catch (error) {
      this.displayError('mcp', 'Erro ao executar teste: ' + error.message);
    }
  }
  
  async handleExecuteCommand() {
    const command = this.elements.commandInput?.value.trim();
    if (!command) {
      this.displayError('mcp', 'Por favor, informe um comando para executar');
      return;
    }
    
    try {
      this.setLoading(true);
      const response = await this.sendAgentRequest('executeCommand', {
        command
      });
      
      if (response.success) {
        this.elements.commandResult.textContent = response.output || 'Comando executado com sucesso';
        this.displaySuccess('mcp', 'Comando executado com sucesso!');
      } else {
        this.elements.commandResult.textContent = 'Erro: ' + (response.error || 'Erro desconhecido');
        this.displayError('mcp', 'Falha ao executar comando: ' + (response.error || 'Erro desconhecido'));
      }
    } catch (error) {
      this.elements.commandResult.textContent = 'Erro: ' + error.message;
      this.displayError('mcp', 'Erro ao executar comando: ' + error.message);
    } finally {
      this.setLoading(false);
    }
  }
  
  copyToClipboard(text) {
    if (!text) {
      this.displayError('general', 'Nada para copiar');
      return;
    }
    
    navigator.clipboard.writeText(text)
      .then(() => {
        // Mensagem de sucesso será exibida pelo chamador
      })
      .catch(err => {
        this.displayError('general', 'Não foi possível copiar o texto: ' + err.message);
      });
  }
  
  /**
   * Exibe uma mensagem de erro na aba especificada
   * @param {string} tab - ID da aba onde exibir o erro (assistant, workflow, docker, mcp, settings)
   * @param {string} message - Mensagem de erro a ser exibida
   */
  displayError(tab, message) {
    const errorContainer = this.elements.errorContainers[tab];
    if (errorContainer) {
      errorContainer.textContent = message;
      errorContainer.style.display = 'block';
      
      // Ocultar mensagem de sucesso, se houver
      const successContainer = this.elements.successContainers[tab];
      if (successContainer) {
        successContainer.style.display = 'none';
      }
      
      // Ocultar automaticamente após 5 segundos
      setTimeout(() => {
        errorContainer.style.display = 'none';
      }, 5000);
    } else {
      console.error(`Container de erro para a aba ${tab} não encontrado`);
    }
  }
  
  /**
   * Exibe uma mensagem de sucesso na aba especificada
   * @param {string} tab - ID da aba onde exibir o sucesso (assistant, workflow, docker, mcp, settings)
   * @param {string} message - Mensagem de sucesso a ser exibida
   */
  displaySuccess(tab, message) {
    const successContainer = this.elements.successContainers[tab];
    if (successContainer) {
      successContainer.textContent = message;
      successContainer.style.display = 'block';
      
      // Ocultar mensagem de erro, se houver
      const errorContainer = this.elements.errorContainers[tab];
      if (errorContainer) {
        errorContainer.style.display = 'none';
      }
      
      // Ocultar automaticamente após 5 segundos
      setTimeout(() => {
        successContainer.style.display = 'none';
      }, 5000);
    } else {
      console.error(`Container de sucesso para a aba ${tab} não encontrado`);
    }
  }
  
  /**
   * Controla o estado de carregamento da interface
   * @param {boolean} isLoading - Se a interface está em estado de carregamento
   */
  setLoading(isLoading) {
    if (this.elements.loadingIndicator) {
      this.elements.loadingIndicator.style.display = isLoading ? 'flex' : 'none';
    }
    
    // Desabilitar/habilitar botões de ação durante o carregamento
    const actionButtons = [
      this.elements.submitButton,
      this.elements.createWorkflowButton,
      this.elements.deployWorkflowButton,
      this.elements.generateDockerComposeButton,
      this.elements.startContainerButton,
      this.elements.stopContainerButton,
      this.elements.clonePlaywrightRepoButton,
      this.elements.generateMcpTestButton,
      this.elements.runMcpTestButton,
      this.elements.executeCommandButton
    ];
    
    actionButtons.forEach(button => {
      if (button) {
        button.disabled = isLoading;
      }
    });
    
    // O botão de salvar configurações sempre permanece habilitado
    if (this.elements.saveSettingsButton) {
      this.elements.saveSettingsButton.disabled = false;
    }
  }
}
